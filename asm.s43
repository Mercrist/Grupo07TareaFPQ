#include "msp430.h"                     ; #define controlled include file

        NAME    main                    ; module name

        PUBLIC  main                    ; make the main label vissible
                                        ; outside this module
        ORG     0FFFEh
        DC16    init                    ; set reset vector to 'init' label

        RSEG    CSTACK                  ; pre-declaration of segment
        RSEG    CODE                    ; place program in 'CODE' segment
        ORG     0x1C00                  ; RAM starting location

; ======== Variable/array directives ========
; ==== Team names ====
; The names' characters are stored with a HB and LB. 6 arrays to accomodate
; the 6 segments. 3 array entries for the 3 names. Values read vertically. 
CHAR1_H db 0x1C, 0xEF, 0x00 ; L, A, Y
CHAR1_L db 0x00, 0x00, 0xB0

CHAR2_H db 0x7C, 0x6C, 0xEF ; U, N, A
CHAR2_L db 0x00, 0x82, 0x00

CHAR3_H db 0x90, 0x80, 0xCF ; I, T, R
CHAR3_L db 0x50, 0x50, 0x02 

CHAR4_H db 0xB7, 0x6F, 0x90 ; S, H, I
CHAR4_L db 0x00, 0x00, 0x50

CHAR5_H db 0x00, 0xFC, 0x9F ; *, O, E
CHAR5_L db 0x00, 0x00, 0x00 

CHAR6_H db 0x00, 0x6C, 0x1C ; *, N, L
CHAR6_L db 0x00, 0x82, 0x00

; ==== Signed/Unsigned options ====
S_OPTION_H db 0xB7, 0x6C ; S and N
S_OPTION_L db 0x00, 0x82

; ==== D->B? / B->D? options ====
CONVERSION_CHAR1_H db 0xF0, 0xF1 ; D, B 
CONVERSION_CHAR1_L db 0x50, 0x50 

CONVERSION_CHAR2_H db 0xF1, 0xF0 ; B + ? (dot), D + ? (dot)  
CONVERSION_CHAR2_L db 0x51, 0x51

; ==== #of Digits (If D->B was choosen) ==== 
DIGITS_H db 0x60, 0xDB ; 1, 2
DIGITS_L db 0x00, 0x00

; ==== #of Bits (If B->D was choosen) ==== 
BITS_H db 0xFC, 0x60, 0xDB, 0xF1, 0x67, 0xB7, 0xBF ; 0,1, 2, 3, 4, 5, 6
BITS_L db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00

; ==== Numbers for selection ===
DEC_NUMS_H db 0xFC, 0x60, 0xDB, 0xF1, 0x67, 0xB7, 0xBF, 0xE0, 0xFF, 0xE7
DEC_NUMS_L db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
;               0     1     2     3     4     5     6     7     8     9

STORED_NUMBER db 0x00, 0x00, 0x00, 0x00, 0x00, 0x00

BIN_NUMS_H db 0xFC, 0x60 ; 0, 1
BIN_NUMS_L db 0x00, 0x00

DEC_SYM_H db 0x03, 0x03 ; + (POS), - (NEG)
DEC_SYM_L db 0x50, 0x00

BIN_SYM_L db 0x00, 0x04 ; (no sign), - (NEG)

; ======== Notes on the registers ========
; R5 : For reading input/P1IN 
; R6 : Array index
; R7 : Stores S/N values
; R8 : Stores conversion values (D -> B)
; R9 : Stores #ofDigits or #ofBits (1-2 for D->B or 0-6 for B->D)
; R10: Delay counter
; R4 : Stores the index of the display position
; R11: Stores the index of the stored numbers array
; R12: Stores the sign of the stored number (if any)

init:   MOV     #SFE(CSTACK), SP        ; set up stack


UnlockGPIO:                             ; Disable de GPIO power-on default
        bic.w   #LOCKLPM5,&PM5CTL0      ; high-impedance mode to activade
                                        ; previously configured port settings

; ======== Ports and LCD setup. Yariel Mercado 10/27/22 ========
setupDisplayAndPorts:     
        ; Manage Ports
        bis.b #11111001B, &P1DIR   ; set P1.1/2 to input 
        mov.b #00000110B, &P1REN   ; activate P1.1/2 pull-up/down resistors
        bis.b #00000110B, &P1OUT   ; set P1.1/2 to pull up resistor
        bic.b #BIT0, &P1OUT        ; set P1.0 LED off 

        ; Enable LCD segments: 0-21, 26-43
        mov #0xFFFF, &LCDCPCTL0
        mov #0xFC3F, &LCDCPCTL1
        mov #0x0FFF, &LCDCPCTL2
          
        ; Initialize LCD 
        mov #0x041e,&LCDCCTL0 ; sets display with hardware specs needed
        mov #0x0208, &LCDCVCTL ; enable voltage for display
        mov #0x8000, &LCDCCPCTL ; enable clock synchronization
        mov #2, &LCDCMEMCTL ; clear LCD memory (resets screen)
        bis #1, &LCDCCTL0 ; turn the LCD on


main:   NOP                             ; main program
        MOV.W   #WDTPW+WDTHOLD,&WDTCTL  ; Stop watchdog timer
        ; main loop for the program (calls the different states)
        call #titleScreen
        call #namesState
        call #signedScreen
        call #conversionScreen
        call #numDigitsBits
        call #numberSelection
        call #programEnd


; ======== Title Screen subroutines. Yariel Mercado 10/27/22 ========
; ======== Draws the title screen and waits for S1.1 input to proceed ========
; F(P.Q)
titleScreen: 
        mov.b #0x8E, &0xA29 ; F 
        mov.b #0x22, &0xA26 ; (
        mov.b #0xCF, &0xA23 ; P
        mov.b #0x01, &0xA24 ; .
        mov.b #0xFC, &0xA32 ; Q
        mov.b #0x02, &0xA33 ; Q (inner line)
        mov.b #0x88, &0xA2F ; )
        push.w R5 ; store original register value
        jmp titleScreenInput 

titleScreenInput:
        ; Check S1.1 button presses
        mov.b &P1IN, R5      ; copy value of the input signal *(ALWAYS USE R5)*
        and.b #BIT1, R5 ; bit mask on S1.1
        cmp.b #00000000B, R5 ; if pressed (sets to 0 when pressed)
        jeq titleScreenDebounce
        jmp titleScreenInput ; continue checking for S1 button presses

titleScreenDebounce:            
        call #S1P1Debounce
        tst.b R5 ; 0 if debounce was succesful
        jnz titleScreenInput ; continue to look for valid button presses
        pop R5
        mov #2, &LCDCMEMCTL  ; clear screen
        ret                  ; succesfully processed button input, back to main

; ======== Name Screen subroutines. Yariel Mercado 10/28/22 ========
; ======== Draws the names of the team members. ========
; ======== S1.1 ends this subroutine. S1.2 advances to the next name. ========
namesState: ; initialize the names loop state
        push.w R5 ; always used to read button states
        push.w R6
        mov #0, R6 ; counter to iterate over the names' arrays
        jmp drawNames ; draw the first name
        
drawNames:  ; 
        mov #2, &LCDCMEMCTL ; redraw the current screen with the next name
        cmp.b #3, R6 ; reloop to the start of the array (last index is 2)
        jeq resetNamesIndex
        ; move each high and low bytes into the corresponding memory segments
        ; character 1
        mov.b CHAR1_H(R6), &0xA29 
        mov.b CHAR1_L(R6), &0xA2A
        ; character 2
        mov.b CHAR2_H(R6), &0xA25
        mov.b CHAR2_L(R6), &0xA26
        ; character 3
        mov.b CHAR3_H(R6), &0xA23
        mov.b CHAR3_L(R6), &0xA24
        ; character 4
        mov.b CHAR4_H(R6), &0xA32
        mov.b CHAR4_L(R6), &0xA33
        ; character 5
        mov.b CHAR5_H(R6), &0xA2E
        mov.b CHAR5_L(R6), &0xA2F
        ; character 6
        mov.b CHAR6_H(R6), &0xA27
        mov.b CHAR6_L(R6), &0xA28
        inc R6
        jmp namesInput
        
resetNamesIndex:
        mov #0, R6 
        jmp drawNames ; R6 can only be reset by pressing S2

namesInput:
        ; Check S1.1/2 button presses
        mov.b &P1IN, R5     
        and.b #00000110B, R5 ; bit mask on S1.1/2
        cmp.b #00000010B, R5 ; if S1.2 is pressed
        jeq namesInputS1P2Debounce 
        cmp.b #00000100B, R5 ; if S1.1 is pressed
        jeq namesInputS1P1Debounce
        jmp namesInput ; continue to cycle for input
        
namesInputS1P2Debounce:  ; S1.2 debouncing
        call #S1P2Debounce
        tst.b R5 ; 0 if debounce was succesful
        jnz namesInput 
        jmp drawNames ; draw the next name if S2 was pressed

namesInputS1P1Debounce:  ; S1.1 debouncing, ends the names subroutines
        call #S1P1Debounce
        tst.b R5 ; 0 if debounce was succesful
        jnz namesInput 
        ; end the names subroutine, restore register values
        pop R6
        pop R5 
        mov #2, &LCDCMEMCTL
        ret  ; return to main

; ======== Signed Screen subroutines. ========
; ======== Yariel Mercado & Anthony Mendez 10/28/22-10/31/22 ========
; ======== Selects signed or unsigned operations ========
; ======== S1.1 accepts an option while S1.2 cycles between them. ========
signedScreen:
        mov.b #0xB7, &0xA29 ; S
        mov.b #0x28, &0xA26 ; /
        mov.b #0x6C, &0xA23 ; N (vertical bars)
        mov.b #0x83, &0xA24 ; N (diagonal part) + ? (dot)
        mov.b #0xCB, &0xA32 ; ? (shape)
        mov.b #0xB7, &0xA27 ; S (default option)
        push.w R5
        push.w R6 ; used to flip between the options
        mov #0, R6 
        jmp signedInput
        
signedInput:
        ; Check S1.1/2 button presses
        mov.b &P1IN, R5     
        and.b #00000110B, R5 ; bit mask on S1.1/2
        cmp.b #00000100B, R5 ; if S1.1 is pressed
        jeq signedS1P1Debounce
        cmp.b #00000010B, R5 ; if S1.2 is pressed
        jeq signedS1P2Debounce
        jmp signedInput ; continue to cycle for input

signedS1P1Debounce: ; selects the users option and ends signed input routines
        call #S1P1Debounce
        tst.b R5 
        jnz signedInput
        ; NOTE: THE USERS CHOICE FOR S/N IS STORED IN R7
        ; 0 == SIGNED, 1 == UNSIGNED
        mov R6, R7  ; store the users option
        pop R6 
        pop R5
        mov #2, &LCDCMEMCTL
        ret
        
signedS1P2Debounce: 
        call #S1P2Debounce 
        tst.b R5 
        jnz signedInput
        ; flip user option if processed succesfully
        xor.b #BIT0, R6 ; toggle LSB to flip between the options
        ; draws the user option
        mov.b S_OPTION_H(R6), &0xA27 ; signed option High/Low byte
        mov.b S_OPTION_L(R6), &0xA28
        jmp signedInput ; continue to read from input

; ===== Conversion Screen subroutines. =====
; ===== Luis D. Gonzalez & Anthony Mendez 10/28/2022-11/1/2022 =====
; ===== Selects D->B or B->D conversion =====
; ===== S1.1 accepts conversion, while S1.2 cycles between them. =====
conversionScreen:
        mov.b #0xF0, &0xA29 ; D (outter bars) [default option]
        mov.b #0x50, &0xA2A ; D (inner bars) [default option]
        mov.b #0x03, &0xA25 ; -
        mov.b #0x88, &0xA24 ; >
        mov.b #0xF1, &0xA32 ; B (outter bars) [default option]
        bis.b #0x51, &0xA33 ; B (inner bars) [default option] + ? (dot)
        mov.b #0xCB, &0xA2E ; ? (shape)
        push.w R5
        push.w R6 ; used to flip between the options
        mov #0, R6 
        jmp conversionInput

conversionInput:
        ; Check S1.1/2 button presses
        mov.b &P1IN, R5     
        and.b #00000110B, R5 ; bit mask on S1.1/2
        cmp.b #00000100B, R5 ; if S1.1 is pressed
        jeq conversionS1P1Debounce
        cmp.b #00000010B, R5 ; if S1.2 is pressed
        jeq conversionS1P2Debounce
        jmp conversionInput ; continue to cycle for input

conversionS1P1Debounce: 
        ; selects the users option and ends conversion input routines
        call #S1P1Debounce
        tst.b R5 
        jnz conversionInput
        ; NOTE: THE USERS CHOICE FOR D->B / B->D IS STORED IN R8
        ; 0 == D->B , 1 == B->D
        mov R6, R8  ; store the users option
        pop R6 
        pop R5
        mov #2, &LCDCMEMCTL
        ret
        
conversionS1P2Debounce:
        call #S1P2Debounce 
        tst.b R5 
        jnz conversionInput
        ; flip user option if processed succesfully
        xor.b #BIT0, R6 ; toggle LSB to flip between the conversions
        ; draws the conversion
        mov.b CONVERSION_CHAR1_H(R6), &0xA29 ; "From" High/Low
        mov.b CONVERSION_CHAR1_L(R6), &0xA2A
        mov.b CONVERSION_CHAR2_H(R6), &0xA32 ; "To" High/Low
        mov.b CONVERSION_CHAR2_L(R6), &0xA33
        jmp conversionInput ; continue to read from input

; ===== Number of Digits/Bits subroutines. =====
; ===== Luis D. Gonzalez 11/1/2022 =====
; ===== Selects 1 or 2 digits between 0-9 (D->B) =====
; ===== Selects 0-6 between 0-1 (B->D) =====
numDigitsBits:
        mov.b #0x6C, &0xA29 ; N (outter bars)
        mov.b #0x82, &0xA2A ; N (inner bars)
        mov.b #0x7C, &0xA25 ; U
        mov.b #0x6C, &0xA23 ; M (outter bars)
        mov.b #0xA1, &0xA24 ; M (inner bars) + ? (dot)
        mov.b #0xCB, &0xA32 ; ? (shape)
        push.w R5
        push.w R6 
        mov #0, R6
        ; Selects whether to flip between digits or bits. 0 == dec
        tst.b R8 
        jeq numDigits
        ; 1 == bin, only other option
        jmp numBits

numDigits:
        ; if user chooses D->B conversion
        mov.b #0x60, &0xA27 ; 1 (outter bars)
        jmp numDigitsInput
        
numBits:
        ; if user choose B->D conversion
        mov.b #0xFC, &0xA27 ; 0
        jmp numBitsInput
        
numDigitsInput:
        ; Check S1.1/2 button presses
        mov.b &P1IN, R5     
        and.b #00000110B, R5 ; bit mask on S1.1/2
        cmp.b #00000100B, R5 ; if S1.1 is pressed
        jeq numDigitsS1P1Debounce
        cmp.b #00000010B, R5 ; if S1.2 is pressed
        jeq numDigitsS1P2Debounce
        jmp numDigitsInput ; continue to cycle for input

numBitsInput:
        ; Check S1.1/2 button presses
        mov.b &P1IN, R5     
        and.b #00000110B, R5 ; bit mask on S1.1/2
        cmp.b #00000100B, R5 ; if S1.1 is pressed
        jeq numBitsS1P1Debounce
        cmp.b #00000010B, R5 ; if S1.2 is pressed
        jeq numBitsS1P2Debounce
        jmp numBitsInput ; continue to cycle for input

numDigitsS1P1Debounce:
        ; selects the users option and ends conversion input routines
        call #S1P1Debounce
        tst.b R5 
        jnz numDigitsInput
        ; NOTE: THE USERS CHOICE FOR #ofDigits IS STORED IN R9 (1 or 2)
        inc R6 ; since R6 is an index, it'll be 0 or 1. Increment to match
               ; user option
        mov R6, R9  ; store the users option
        pop R6 
        pop R5
        mov #2, &LCDCMEMCTL
        ret

numDigitsS1P2Debounce:
        call #S1P2Debounce 
        tst.b R5 
        jnz numDigitsInput
        ; flip user option if processed succesfully
        xor.b #BIT0, R6 ; toggle LSB to flip between the digit numbers
        ; draws the digit number
        mov.b DIGITS_H(R6), &0xA27 ; Flips between one and two
        mov.b DIGITS_L(R6), &0xA28 ; 
        jmp numDigitsInput ; continue to read from input
        
numBitsS1P1Debounce:
        ; selects the users option and ends conversion input routines
        call #S1P1Debounce
        tst.b R5 
        jnz numBitsInput
        ; NOTE: THE USERS CHOICE FOR #ofBits IS STORED IN R9 (0-6)
        mov R6, R9  ; store the users option (options here match indexes)
        pop R6 
        pop R5
        mov #2, &LCDCMEMCTL
        ret

numBitsS1P2Debounce:
        call #S1P2Debounce 
        tst.b R5 
        jnz numBitsInput
        inc R6 ; increment and then display the option (leads to cycling bugs)
        jmp cycleBits

cycleBits: ; cycle between the 0-6 options (avoid debouncing twice)
        cmp.b #7, R6 ; if R6 is equal to length of array, reset R6 to 0 again
        jeq resetRegister 
        ; draws the conversion
        mov.b BITS_H(R6), &0xA27 
        mov.b BITS_L(R6), &0xA28 
        jmp numBitsInput ; continue to read from input

resetRegister:
        mov #0, R6
        jmp cycleBits
        
; ===== Number selection subroutines. =====
; ===== Anthony Mendez 11/2/2022-11/3/2022 =====
; ===== Selects the number to be converted (from right to left) =====
; ===== S1.1 confirms selection; S1.2 cycles numbers. =====
; ===== For D->B, the leftmost segment will show sign if selected in S/N?=====
numberSelection:
        push.w R5
        push.w R6
        mov #0, R4
        mov #0, R11
        mov #1, R6  ;index starts at 1 for the first value
        ; Selects whether to cycle through dec or bin nums. 0 == dec
        tst.b R8 
        jeq decimalCycle
        ; 1 == bin, only other option
        ;jmp binaryCycle
        
decimalCycle:
        mov.b #0xFC, &0xA25 ; 0 (most significant digit)
        mov.b #0x01, &0xA26 ; . (dot for decimals) here by default
        mov.b #0xFC, &0xA23 ; 0
        mov.b #0xFC, &0xA32 ; 0
        mov.b #0xFC, &0xA2E ; 0
        mov.b #0xFC, &0xA27 ; 0
        call #overwriteDot 
        cmp.b #0 ,R7 ; if the user selected sign
        jeq drawSign ; draw sign, else leave space empty
        jmp decimalInput

overwriteDot:
        cmp.b #2 ,R9  ; if the user selected 2 digits
        jeq drawDigit ; move the dot, else leave as it is
        ret
        drawDigit:
                mov.b #0x00, &0xA26 ; removing dot
                mov.b #0x01, &0xA24 ; . (dot for decimals)
        ret
        
drawSign:
        mov.b #0x03, &0xA29 ; + (positive sign)default
        mov.b #0x50, &0xA2A
        jmp decimalInput

decimalInput:
        ; Check S1.1/2 button presses
        mov.b &P1IN, R5     
        and.b #00000110B, R5 ; bit mask on S1.1/2
        cmp.b #00000100B, R5 ; if S1.1 is pressed
        jeq decSelectionS1P1Debounce
        cmp.b #00000010B, R5 ; if S1.2 is pressed
        jeq decSelectionS1P2Debounce
        jmp decimalInput ; continue to cycle for input
        
decSelectionS1P1Debounce:
        ; Confirms the decimal number selection
        call #S1P1Debounce
        tst.b R5 
        jnz decimalInput
        dec R6 ; substract the index added with S1P2 to store exact value
        mov R6, STORED_NUMBER(R11) ; save values and then index++
        inc R11                    ; We don't worry about the dot because we
        mov R6, R15 ; testing, delete later  ; verify the position with R9
        mov #0, R6 ;reset so that next number starts at zero
        inc R4 ; increment display position array index
        cmp.b #5, R4 ; if the next display is the leftmost,
        jeq isItSigned ;question if its signed
        cmp.b #6, R4 ; finish selection once everything is picked
        jeq finishSelection
        jmp cycleHub
        
isItSigned:
        cmp.b #0, R7 ; if R7
        jeq cycleDecimalSign
        jmp finishSelection ;if not signed, finish
        
finishSelection:
        pop R6 
        pop R5
        pop R4
        mov #2, &LCDCMEMCTL
        ret
        
decSelectionS1P2Debounce:
        call #S1P2Debounce 
        tst.b R5 
        jnz decimalInput
        jmp cycleHub   
        
cycleHub:
        cmp.b #0, R4
        jeq cycleDecimalNum0
        cmp.b #1, R4
        jeq cycleDecimalNum1
        cmp.b #2, R4
        jeq cycleDecimalNum2
        cmp.b #3, R4
        jeq cycleDecimalNum3
        cmp.b #4, R4
        jeq cycleDecimalNum4
        cmp.b #0, R7
        jeq cycleDecimalSign
        
cycleDecimalNum0:
        call #resetDecArrayIndex
        mov.b DEC_NUMS_H(R6), &0xA27
        mov.b DEC_NUMS_L(R6), &0xA28
        inc R6
        jmp decimalInput ; continue to read from input
        
cycleDecimalNum1:
        call #resetDecArrayIndex
        mov.b DEC_NUMS_H(R6), &0xA2E
        mov.b DEC_NUMS_L(R6), &0xA2F
        inc R6
        jmp decimalInput ; continue to read from input

cycleDecimalNum2:
        call #resetDecArrayIndex
        mov.b DEC_NUMS_H(R6), &0xA32
        mov.b DEC_NUMS_L(R6), &0xA33
        inc R6
        jmp decimalInput ; continue to read from input

cycleDecimalNum3:
        call #resetDecArrayIndex
        mov.b DEC_NUMS_H(R6), &0xA23
        bis.b DEC_NUMS_L(R6), &0xA24 ; array with numbers with . (dot)
        inc R6
        jmp decimalInput ; continue to read from input

cycleDecimalNum4:
        call #resetDecArrayIndex
        mov.b DEC_NUMS_H(R6), &0xA25
        bis.b DEC_NUMS_L(R6), &0xA26
        inc R6
        jmp decimalInput ; continue to read from input

cycleDecimalSign:
        call #resetSignArrayIndex
        mov.b DEC_SYM_H(R6), &0xA29
        mov.b DEC_SYM_L(R6), &0xA2A
        mov R6, R12 ; store 0 if positive, 1 if negative
        inc R6
        jmp decimalInput ; continue to read from input
        
resetSignArrayIndex:
        cmp.b #2, R6 ; if R6 == 2, reset to 0 because the last sign index is 1 
        jeq signIndexReseter
        ret
        signIndexReseter:
                mov #0, R6
        ret
         
resetDecArrayIndex:
        cmp.b #10, R6 ; if R6 == 10, reset to 0 because the last number is 9
        jeq decIndexReseter
        ret
        decIndexReseter:
                mov #0, R6
        ret
        
;binaryCycle:
;        mov.b 0xFC, &0xA29 ; 0 (6th bit)
;        mov.b 0xFC, &0xA25 ; 0 (5th bit)
;        mov.b 0xFC, &0xA23 ; 0 (4th bit)
;        mov.b 0xFC, &0xA32 ; 0 (3rd bit)
;        mov.b 0xFC, &0xA2E ; 0 (2nd bit)
;        mov.b 0xFC, &0xA27 ; 0 (1st bit)

;              0      1      2      3      4      5     
;POSITION_H 0xA27, 0xA2E, 0xA32, 0xA23, 0xA25, 0xA29 Right to Left
;POSITION_L 0xA28, 0xA2F, 0xA33, 0xA24, 0xA26, 0xA2A

; ======== Debounce subroutines. Yariel Mercado 10/28/22 ========
; ======== General delay subroutines for the individual buttons ========
; Note: R5 should always be used to check for pin states and this register's 
;       value should be preserved and handled by the subroutine calling the
;       debouncing. 
S1P1Debounce: ; S1 Pin 1
        call #delay ; debouncing
        mov.b &P1IN, R5 ; recheck P1.1 value to check if it was really pressed
        and.b #BIT1, R5 
        sub.b #00000010B, R5 ; should be no longer pressed, avoids long presses
                             ; if these are the same, R5 == 0
        ret
 
S1P2Debounce: ; S1 Pin 2
        call #delay ; debouncing
        mov.b &P1IN, R5 ; recheck P1.2 value to check if it was really pressed
        and.b #BIT2, R5 
        sub.b #00000100B, R5 
        ret

; ======== Delay subroutines. Yariel Mercado 10/27/22 ========
; ======== Decrements from a large value to stall for time. ========
delay:
        push.w R10 ; store original value
        mov #0xFF, R10
        jmp loop
        
loop:
        dec R10
        jnz loop
        pop R10 
        ret ; returns to whatever subroutine the delay was called from

; End loop for the program
programEnd:
        JMP $                           ; jump to current location '$'
                                        ; (endless loop)
        NOP
        END
